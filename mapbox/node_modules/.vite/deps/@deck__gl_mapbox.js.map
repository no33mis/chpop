{
  "version": 3,
  "sources": ["../../@deck.gl/mapbox/src/deck-utils.ts", "../../@deck.gl/mapbox/src/mapbox-layer.ts", "../../@deck.gl/mapbox/src/resolve-layers.ts", "../../@deck.gl/mapbox/src/mapbox-overlay.ts"],
  "sourcesContent": ["import {Deck, WebMercatorViewport, MapView, _flatten as flatten} from '@deck.gl/core';\nimport type {DeckProps, MapViewState, Layer} from '@deck.gl/core';\nimport type MapboxLayer from './mapbox-layer';\nimport type {Map} from 'mapbox-gl';\n\nimport {lngLatToWorld, unitsPerMeter} from '@math.gl/web-mercator';\nimport GL from '@luma.gl/constants';\n\ntype UserData = {\n  isExternal: boolean;\n  currentViewport?: WebMercatorViewport | null;\n  mapboxLayers: Set<MapboxLayer<any>>;\n  // mapboxVersion: {minor: number; major: number};\n};\n\n// Mercator constants\nconst TILE_SIZE = 512;\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\n// Create an interleaved deck instance.\nexport function getDeckInstance({\n  map,\n  gl,\n  deck\n}: {\n  map: Map & {__deck?: Deck | null};\n  gl: WebGLRenderingContext;\n  deck?: Deck;\n}): Deck {\n  // Only create one deck instance per context\n  if (map.__deck) {\n    return map.__deck;\n  }\n\n  // Only initialize certain props once per context\n  const customRender = deck?.props._customRender;\n  const onLoad = deck?.props.onLoad;\n\n  const deckProps = getInterleavedProps({\n    ...deck?.props,\n    _customRender: () => {\n      map.triggerRepaint();\n      // customRender may be subscribed by DeckGL React component to update child props\n      // make sure it is still called\n      // Hack - do not pass a redraw reason here to prevent the React component from clearing the context\n      // Rerender will be triggered by MapboxLayer's render()\n      customRender?.('');\n    }\n  });\n\n  let deckInstance: Deck;\n\n  if (!deck || deck.props.gl === gl) {\n    // If deck isn't defined (Internal MapboxLayer use case),\n    // or if deck is defined and is using the WebGLContext created by mapbox (MapboxOverlay and External MapboxLayer use case),\n    // block deck from setting the canvas size, and use the map's viewState to drive deck.\n    // Otherwise, we use deck's viewState to drive the map.\n    Object.assign(deckProps, {\n      gl,\n      width: null,\n      height: null,\n      touchAction: 'unset',\n      viewState: getViewState(map)\n    });\n    if (deck?.isInitialized) {\n      watchMapMove(deck, map);\n    } else {\n      deckProps.onLoad = () => {\n        onLoad?.();\n        watchMapMove(deckInstance, map);\n      };\n    }\n  }\n\n  if (deck) {\n    deckInstance = deck;\n    deck.setProps(deckProps);\n    (deck.userData as UserData).isExternal = true;\n  } else {\n    deckInstance = new Deck(deckProps);\n    map.on('remove', () => {\n      removeDeckInstance(map);\n    });\n  }\n\n  (deckInstance.userData as UserData).mapboxLayers = new Set();\n  // (deckInstance.userData as UserData).mapboxVersion = getMapboxVersion(map);\n  map.__deck = deckInstance;\n  map.on('render', () => {\n    if (deckInstance.isInitialized) afterRender(deckInstance, map);\n  });\n\n  return deckInstance;\n}\n\nfunction watchMapMove(deck: Deck, map: Map & {__deck?: Deck | null}) {\n  const _handleMapMove = () => {\n    if (deck.isInitialized) {\n      // call view state methods\n      onMapMove(deck, map);\n    } else {\n      // deregister itself when deck is finalized\n      map.off('move', _handleMapMove);\n    }\n  };\n  map.on('move', _handleMapMove);\n}\n\nexport function removeDeckInstance(map: Map & {__deck?: Deck | null}) {\n  map.__deck?.finalize();\n  map.__deck = null;\n}\n\nexport function getInterleavedProps(currProps: DeckProps) {\n  const nextProps: DeckProps = {\n    ...currProps,\n    // TODO: import these defaults from a single source of truth\n    parameters: {\n      depthMask: true,\n      depthTest: true,\n      blend: true,\n      blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA],\n      polygonOffsetFill: true,\n      depthFunc: GL.LEQUAL,\n      blendEquation: GL.FUNC_ADD,\n      ...currProps.parameters\n    },\n    views: currProps.views || [new MapView({id: 'mapbox'})]\n  };\n\n  return nextProps;\n}\n\nexport function addLayer(deck: Deck, layer: MapboxLayer<any>): void {\n  (deck.userData as UserData).mapboxLayers.add(layer);\n  updateLayers(deck);\n}\n\nexport function removeLayer(deck: Deck, layer: MapboxLayer<any>): void {\n  (deck.userData as UserData).mapboxLayers.delete(layer);\n  updateLayers(deck);\n}\n\nexport function updateLayer(deck: Deck, layer: MapboxLayer<any>): void {\n  updateLayers(deck);\n}\n\nexport function drawLayer(deck: Deck, map: Map, layer: MapboxLayer<any>): void {\n  let {currentViewport} = deck.userData as UserData;\n  let clearStack: boolean = false;\n  if (!currentViewport) {\n    // This is the first layer drawn in this render cycle.\n    // Generate viewport from the current map state.\n    currentViewport = getViewport(deck, map, true);\n    (deck.userData as UserData).currentViewport = currentViewport;\n    clearStack = true;\n  }\n\n  if (!deck.isInitialized) {\n    return;\n  }\n\n  deck._drawLayers('mapbox-repaint', {\n    viewports: [currentViewport],\n    layerFilter: ({layer: deckLayer}) =>\n      layer.id === deckLayer.id || deckLayer.props.operation.includes('terrain'),\n    clearStack,\n    clearCanvas: false\n  });\n}\n\nexport function getViewState(map: Map): MapViewState & {\n  repeat: boolean;\n  padding: {\n    left: number;\n    right: number;\n    top: number;\n    bottom: number;\n  };\n} {\n  const {lng, lat} = map.getCenter();\n\n  const viewState: MapViewState & {\n    repeat: boolean;\n    padding: {\n      left: number;\n      right: number;\n      top: number;\n      bottom: number;\n    };\n  } = {\n    // Longitude returned by getCenter can be outside of [-180, 180] when zooming near the anti meridian\n    // https://github.com/visgl/deck.gl/issues/6894\n    longitude: ((lng + 540) % 360) - 180,\n    latitude: lat,\n    zoom: map.getZoom(),\n    bearing: map.getBearing(),\n    pitch: map.getPitch(),\n    padding: map.getPadding(),\n    repeat: map.getRenderWorldCopies()\n  };\n\n  if (map.getTerrain?.()) {\n    // When the base map has terrain, we need to target the camera at the terrain surface\n    centerCameraOnTerrain(map, viewState);\n  }\n\n  return viewState;\n}\n\nfunction centerCameraOnTerrain(map: Map, viewState: MapViewState) {\n  if (map.getFreeCameraOptions) {\n    // mapbox-gl v2\n    const {position} = map.getFreeCameraOptions();\n    if (!position || position.z === undefined) {\n      return;\n    }\n\n    // @ts-ignore transform is not typed\n    const height = map.transform.height;\n    const {longitude, latitude, pitch} = viewState;\n\n    // Convert mapbox mercator coordinate to deck common space\n    const cameraX = position.x * TILE_SIZE;\n    const cameraY = (1 - position.y) * TILE_SIZE;\n    const cameraZ = position.z * TILE_SIZE;\n\n    // Mapbox manipulates zoom in terrain mode, see discussion here: https://github.com/mapbox/mapbox-gl-js/issues/12040\n    const center = lngLatToWorld([longitude, latitude]);\n    const dx = cameraX - center[0];\n    const dy = cameraY - center[1];\n    const cameraToCenterDistanceGround = Math.sqrt(dx * dx + dy * dy);\n\n    const pitchRadians = pitch! * DEGREES_TO_RADIANS;\n    const altitudePixels = 1.5 * height;\n    const scale =\n      pitchRadians < 0.001\n        ? // Pitch angle too small to deduce the look at point, assume elevation is 0\n          (altitudePixels * Math.cos(pitchRadians)) / cameraZ\n        : (altitudePixels * Math.sin(pitchRadians)) / cameraToCenterDistanceGround;\n    viewState.zoom = Math.log2(scale);\n\n    const cameraZFromSurface = (altitudePixels * Math.cos(pitchRadians)) / scale;\n    const surfaceElevation = cameraZ - cameraZFromSurface;\n    viewState.position = [0, 0, surfaceElevation / unitsPerMeter(latitude)];\n  }\n  // @ts-ignore transform is not typed\n  else if (typeof map.transform.elevation === 'number') {\n    // maplibre-gl\n    // @ts-ignore transform is not typed\n    viewState.position = [0, 0, map.transform.elevation];\n  }\n}\n\n// function getMapboxVersion(map: Map): {minor: number; major: number} {\n//   // parse mapbox version string\n//   let major = 0;\n//   let minor = 0;\n//   // @ts-ignore (2339) undefined property\n//   const version: string = map.version;\n//   if (version) {\n//     [major, minor] = version.split('.').slice(0, 2).map(Number);\n//   }\n//   return {major, minor};\n// }\n\nfunction getViewport(deck: Deck, map: Map, useMapboxProjection = true): WebMercatorViewport {\n  return new WebMercatorViewport({\n    id: 'mapbox',\n    x: 0,\n    y: 0,\n    width: deck.width,\n    height: deck.height,\n    ...getViewState(map),\n    nearZMultiplier: useMapboxProjection\n      ? // match mapbox-gl@>=1.3.0's projection matrix\n        0.02\n      : // use deck.gl's own default\n        0.1,\n    // @ts-expect-error Mapbox specific - extract near plane position\n    nearZ: map.transform._nearZ / map.transform.height,\n    // @ts-expect-error Mapbox specific - extract far plane position\n    farZ: map.transform._farZ / map.transform.height\n  });\n}\n\nfunction afterRender(deck: Deck, map: Map): void {\n  const {mapboxLayers, isExternal} = deck.userData as UserData;\n\n  if (isExternal) {\n    // Draw non-Mapbox layers\n    const mapboxLayerIds = Array.from(mapboxLayers, layer => layer.id);\n    const deckLayers = flatten(deck.props.layers, Boolean) as Layer[];\n    const hasNonMapboxLayers = deckLayers.some(\n      layer => layer && !mapboxLayerIds.includes(layer.id)\n    );\n    let viewports = deck.getViewports();\n    const mapboxViewportIdx = viewports.findIndex(vp => vp.id === 'mapbox');\n    const hasNonMapboxViews = viewports.length > 1 || mapboxViewportIdx < 0;\n\n    if (hasNonMapboxLayers || hasNonMapboxViews) {\n      if (mapboxViewportIdx >= 0) {\n        viewports = viewports.slice();\n        viewports[mapboxViewportIdx] = getViewport(deck, map, false);\n      }\n\n      deck._drawLayers('mapbox-repaint', {\n        viewports,\n        layerFilter: params =>\n          (!deck.props.layerFilter || deck.props.layerFilter(params)) &&\n          (params.viewport.id !== 'mapbox' || !mapboxLayerIds.includes(params.layer.id)),\n        clearCanvas: false\n      });\n    }\n  }\n\n  // End of render cycle, clear generated viewport\n  (deck.userData as UserData).currentViewport = null;\n}\n\nfunction onMapMove(deck: Deck, map: Map): void {\n  deck.setProps({\n    viewState: getViewState(map)\n  });\n  // Camera changed, will trigger a map repaint right after this\n  // Clear any change flag triggered by setting viewState so that deck does not request\n  // a second repaint\n  deck.needsRedraw({clearRedrawFlags: true});\n}\n\nfunction updateLayers(deck: Deck): void {\n  if ((deck.userData as UserData).isExternal) {\n    return;\n  }\n\n  const layers: Layer[] = [];\n  (deck.userData as UserData).mapboxLayers.forEach(deckLayer => {\n    const LayerType = deckLayer.props.type;\n    const layer = new LayerType(deckLayer.props);\n    layers.push(layer);\n  });\n  deck.setProps({layers});\n}\n", "import {getDeckInstance, addLayer, removeLayer, updateLayer, drawLayer} from './deck-utils';\nimport type {Map, CustomLayerInterface} from 'mapbox-gl';\nimport type {Deck, Layer} from '@deck.gl/core';\n\nexport type MapboxLayerProps<LayerT extends Layer> = Partial<LayerT['props']> & {\n  id: string;\n  renderingMode?: '2d' | '3d';\n  deck?: Deck;\n};\n\nexport default class MapboxLayer<LayerT extends Layer> implements CustomLayerInterface {\n  id: string;\n  type: 'custom';\n  renderingMode: '2d' | '3d';\n  map: Map | null;\n  deck: Deck | null;\n  props: MapboxLayerProps<LayerT>;\n\n  /* eslint-disable no-this-before-super */\n  constructor(props: MapboxLayerProps<LayerT>) {\n    if (!props.id) {\n      throw new Error('Layer must have an unique id');\n    }\n\n    this.id = props.id;\n    this.type = 'custom';\n    this.renderingMode = props.renderingMode || '3d';\n    this.map = null;\n    this.deck = null;\n    this.props = props;\n  }\n\n  /* Mapbox custom layer methods */\n\n  onAdd(map: Map, gl: WebGLRenderingContext): void {\n    this.map = map;\n    this.deck = getDeckInstance({map, gl, deck: this.props.deck});\n    addLayer(this.deck, this);\n  }\n\n  onRemove(): void {\n    if (this.deck) {\n      removeLayer(this.deck, this);\n    }\n  }\n\n  setProps(props: MapboxLayerProps<LayerT>) {\n    // id cannot be changed\n    Object.assign(this.props, props, {id: this.id});\n    // safe guard in case setProps is called before onAdd\n    if (this.deck) {\n      updateLayer(this.deck, this);\n    }\n  }\n\n  render() {\n    drawLayer(this.deck!, this.map!, this);\n  }\n}\n", "import {_flatten as flatten} from '@deck.gl/core';\nimport MapboxLayer from './mapbox-layer';\n\nimport type {Deck, LayersList, Layer} from '@deck.gl/core';\nimport type {Map} from 'mapbox-gl';\n\nconst UNDEFINED_BEFORE_ID = '__UNDEFINED__';\n\n/** Insert Deck layers into the mapbox Map according to the user-defined order */\n// eslint-disable-next-line complexity, max-statements\nexport function resolveLayers(\n  map?: Map,\n  deck?: Deck,\n  oldLayers?: LayersList,\n  newLayers?: LayersList\n) {\n  // Wait until map style is loaded\n  // @ts-ignore non-public map property\n  if (!map || !deck || !map.style || !map.style._loaded) {\n    return;\n  }\n\n  const layers = flatten(newLayers, Boolean) as Layer[];\n\n  if (oldLayers !== newLayers) {\n    // Step 1: remove layers that no longer exist\n    const prevLayers = flatten(oldLayers, Boolean) as Layer[];\n    const prevLayerIds = new Set<string>(prevLayers.map(l => l.id));\n\n    for (const layer of layers) {\n      prevLayerIds.delete(layer.id);\n    }\n\n    for (const id of prevLayerIds) {\n      if (map.getLayer(id)) {\n        map.removeLayer(id);\n      }\n    }\n  }\n\n  // Step 2: add missing layers\n  for (const layer of layers) {\n    const mapboxLayer = map.getLayer(layer.id) as MapboxLayer<Layer>;\n    if (mapboxLayer) {\n      // @ts-expect-error not typed\n      mapboxLayer.implementation.setProps(layer.props);\n    } else {\n      map.addLayer(\n        new MapboxLayer({id: layer.id, deck}),\n        // @ts-expect-error beforeId is not defined in LayerProps\n        layer.props.beforeId\n      );\n    }\n  }\n\n  // Step 3: check the order of layers\n  // If beforeId is defined, the deck layer should always render before the mapbox layer [beforeId]\n  // If beforeId is not defined, the deck layer should appear after all mapbox layers\n  // When two deck layers share the same beforeId, they are rendered in the order that is passed into Deck props.layers\n  // @ts-ignore non-public map property\n  const mapLayers: string[] = map.style._order;\n\n  // Group deck layers by beforeId\n  const layerGroups: Record<string, string[]> = {};\n  for (const layer of layers) {\n    // @ts-expect-error beforeId is not defined in LayerProps\n    let {beforeId} = layer.props;\n    if (!beforeId || !mapLayers.includes(beforeId)) {\n      beforeId = UNDEFINED_BEFORE_ID;\n    }\n    layerGroups[beforeId] = layerGroups[beforeId] || [];\n    layerGroups[beforeId].push(layer.id);\n  }\n\n  for (const beforeId in layerGroups) {\n    const layerGroup = layerGroups[beforeId];\n    let lastLayerIndex =\n      beforeId === UNDEFINED_BEFORE_ID ? mapLayers.length : mapLayers.indexOf(beforeId);\n    let lastLayerId = beforeId === UNDEFINED_BEFORE_ID ? undefined : beforeId;\n    for (let i = layerGroup.length - 1; i >= 0; i--) {\n      const layerId = layerGroup[i];\n      const layerIndex = mapLayers.indexOf(layerId);\n      if (layerIndex !== lastLayerIndex - 1) {\n        map.moveLayer(layerId, lastLayerId);\n        if (layerIndex > lastLayerIndex) {\n          // The last layer's index have changed\n          lastLayerIndex++;\n        }\n      }\n      lastLayerIndex--;\n      lastLayerId = layerId;\n    }\n  }\n}\n", "import {Deck, assert} from '@deck.gl/core';\nimport {getViewState, getDeckInstance, removeDeckInstance, getInterleavedProps} from './deck-utils';\n\nimport type {Map, IControl, MapMouseEvent} from 'mapbox-gl';\nimport type {MjolnirGestureEvent, MjolnirPointerEvent} from 'mjolnir.js';\nimport type {DeckProps} from '@deck.gl/core';\n\nimport {resolveLayers} from './resolve-layers';\n\nexport type MapboxOverlayProps = Omit<\n  DeckProps,\n  | 'width'\n  | 'height'\n  | 'gl'\n  | 'parent'\n  | 'canvas'\n  | '_customRender'\n  | 'viewState'\n  | 'initialViewState'\n  | 'controller'\n> & {\n  interleaved?: boolean;\n};\n\n/**\n * Implements Mapbox [IControl](https://docs.mapbox.com/mapbox-gl-js/api/markers/#icontrol) interface\n * Renders deck.gl layers over the base map and automatically synchronizes with the map's camera\n */\nexport default class MapboxOverlay implements IControl {\n  private _props: MapboxOverlayProps;\n  private _deck?: Deck;\n  private _map?: Map;\n  private _container?: HTMLDivElement;\n  private _interleaved: boolean;\n  private _lastMouseDownPoint?: {x: number; y: number; clientX: number; clientY: number};\n\n  constructor(props: MapboxOverlayProps) {\n    const {interleaved = false, ...otherProps} = props;\n    this._interleaved = interleaved;\n    this._props = otherProps;\n  }\n\n  /** Update (partial) props of the underlying Deck instance. */\n  setProps(props: MapboxOverlayProps): void {\n    if (this._interleaved && props.layers) {\n      resolveLayers(this._map, this._deck, this._props.layers, props.layers);\n    }\n\n    Object.assign(this._props, props);\n\n    if (this._deck) {\n      this._deck.setProps(this._interleaved ? getInterleavedProps(this._props) : this._props);\n    }\n  }\n\n  /** Called when the control is added to a map */\n  onAdd(map: Map): HTMLDivElement {\n    this._map = map;\n    return this._interleaved ? this._onAddInterleaved(map) : this._onAddOverlaid(map);\n  }\n\n  private _onAddOverlaid(map: Map): HTMLDivElement {\n    /* global document */\n    const container = document.createElement('div');\n    Object.assign(container.style, {\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      textAlign: 'initial',\n      pointerEvents: 'none'\n    });\n    this._container = container;\n\n    this._deck = new Deck({\n      ...this._props,\n      parent: container,\n      viewState: getViewState(map)\n    });\n\n    map.on('resize', this._updateContainerSize);\n    map.on('render', this._updateViewState);\n    map.on('mousedown', this._handleMouseEvent);\n    map.on('dragstart', this._handleMouseEvent);\n    map.on('drag', this._handleMouseEvent);\n    map.on('dragend', this._handleMouseEvent);\n    map.on('mousemove', this._handleMouseEvent);\n    map.on('mouseout', this._handleMouseEvent);\n    map.on('click', this._handleMouseEvent);\n    map.on('dblclick', this._handleMouseEvent);\n\n    this._updateContainerSize();\n    return container;\n  }\n\n  private _onAddInterleaved(map: Map): HTMLDivElement {\n    this._deck = getDeckInstance({\n      map,\n      // @ts-ignore non-public map property\n      gl: map.painter.context.gl,\n      deck: new Deck({\n        ...this._props,\n        // @ts-ignore non-public map property\n        gl: map.painter.context.gl\n      })\n    });\n\n    map.on('styledata', this._handleStyleChange);\n    resolveLayers(map, this._deck, [], this._props.layers);\n\n    return document.createElement('div');\n  }\n\n  /** Called when the control is removed from a map */\n  onRemove(): void {\n    const map = this._map;\n\n    if (map) {\n      if (this._interleaved) {\n        this._onRemoveInterleaved(map);\n      } else {\n        this._onRemoveOverlaid(map);\n      }\n    }\n\n    this._deck = undefined;\n    this._map = undefined;\n    this._container = undefined;\n  }\n\n  private _onRemoveOverlaid(map: Map): void {\n    map.off('resize', this._updateContainerSize);\n    map.off('render', this._updateViewState);\n    map.off('mousedown', this._handleMouseEvent);\n    map.off('dragstart', this._handleMouseEvent);\n    map.off('drag', this._handleMouseEvent);\n    map.off('dragend', this._handleMouseEvent);\n    map.off('mousemove', this._handleMouseEvent);\n    map.off('mouseout', this._handleMouseEvent);\n    map.off('click', this._handleMouseEvent);\n    map.off('dblclick', this._handleMouseEvent);\n    this._deck?.finalize();\n  }\n\n  private _onRemoveInterleaved(map: Map): void {\n    map.off('styledata', this._handleStyleChange);\n    resolveLayers(map, this._deck, this._props.layers, []);\n    removeDeckInstance(map);\n  }\n\n  getDefaultPosition() {\n    return 'top-left';\n  }\n\n  /** Forwards the Deck.pickObject method */\n  pickObject(params: Parameters<Deck['pickObject']>[0]): ReturnType<Deck['pickObject']> {\n    assert(this._deck);\n    return this._deck.pickObject(params);\n  }\n\n  /** Forwards the Deck.pickMultipleObjects method */\n  pickMultipleObjects(\n    params: Parameters<Deck['pickMultipleObjects']>[0]\n  ): ReturnType<Deck['pickMultipleObjects']> {\n    assert(this._deck);\n    return this._deck.pickMultipleObjects(params);\n  }\n\n  /** Forwards the Deck.pickObjects method */\n  pickObjects(params: Parameters<Deck['pickObjects']>[0]): ReturnType<Deck['pickObjects']> {\n    assert(this._deck);\n    return this._deck.pickObjects(params);\n  }\n\n  /** Remove from map and releases all resources */\n  finalize() {\n    if (this._map) {\n      this._map.removeControl(this);\n    }\n  }\n\n  /** If interleaved: true, returns base map's canvas, otherwise forwards the Deck.getCanvas method. */\n  getCanvas(): HTMLCanvasElement | null {\n    if (!this._map) {\n      return null;\n    }\n\n    return this._interleaved ? this._map.getCanvas() : this._deck!.getCanvas();\n  }\n\n  private _handleStyleChange = () => {\n    resolveLayers(this._map, this._deck, this._props.layers, this._props.layers);\n  };\n\n  private _updateContainerSize = () => {\n    if (this._map && this._container) {\n      const {clientWidth, clientHeight} = this._map.getContainer();\n      Object.assign(this._container.style, {\n        width: `${clientWidth}px`,\n        height: `${clientHeight}px`\n      });\n    }\n  };\n\n  private _updateViewState = () => {\n    const deck = this._deck;\n    if (deck) {\n      // @ts-ignore (2345) map is always defined if deck is\n      deck.setProps({viewState: getViewState(this._map)});\n      // Redraw immediately if view state has changed\n      if (deck.isInitialized) {\n        deck.redraw();\n      }\n    }\n  };\n\n  private _handleMouseEvent = (event: MapMouseEvent) => {\n    const deck = this._deck;\n    if (!deck || !deck.isInitialized) {\n      return;\n    }\n\n    const mockEvent: {\n      type: string;\n      deltaX?: number;\n      deltaY?: number;\n      offsetCenter: {x: number; y: number};\n      srcEvent: MapMouseEvent;\n      tapCount?: number;\n    } = {\n      type: event.type,\n      offsetCenter: event.point,\n      srcEvent: event\n    };\n\n    const lastDown = this._lastMouseDownPoint;\n    if (!event.point && lastDown) {\n      // drag* events do not contain a `point` field\n      mockEvent.deltaX = event.originalEvent.clientX - lastDown.clientX;\n      mockEvent.deltaY = event.originalEvent.clientY - lastDown.clientY;\n      mockEvent.offsetCenter = {\n        x: lastDown.x + mockEvent.deltaX,\n        y: lastDown.y + mockEvent.deltaY\n      };\n    }\n\n    switch (mockEvent.type) {\n      case 'mousedown':\n        deck._onPointerDown(mockEvent as MjolnirGestureEvent);\n        this._lastMouseDownPoint = {\n          ...event.point,\n          clientX: event.originalEvent.clientX,\n          clientY: event.originalEvent.clientY\n        };\n        break;\n\n      case 'dragstart':\n        mockEvent.type = 'panstart';\n        deck._onEvent(mockEvent as MjolnirGestureEvent);\n        break;\n\n      case 'drag':\n        mockEvent.type = 'panmove';\n        deck._onEvent(mockEvent as MjolnirGestureEvent);\n        break;\n\n      case 'dragend':\n        mockEvent.type = 'panend';\n        deck._onEvent(mockEvent as MjolnirGestureEvent);\n        break;\n\n      case 'click':\n        mockEvent.tapCount = 1;\n        deck._onEvent(mockEvent as MjolnirGestureEvent);\n        break;\n\n      case 'dblclick':\n        mockEvent.type = 'click';\n        mockEvent.tapCount = 2;\n        deck._onEvent(mockEvent as MjolnirGestureEvent);\n        break;\n\n      case 'mousemove':\n        mockEvent.type = 'pointermove';\n        deck._onPointerMove(mockEvent as MjolnirPointerEvent);\n        break;\n\n      case 'mouseout':\n        mockEvent.type = 'pointerleave';\n        deck._onPointerMove(mockEvent as MjolnirPointerEvent);\n        break;\n\n      default:\n        return;\n    }\n  };\n}\n"],
  "mappings": "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",
  "names": ["TILE_SIZE", "DEGREES_TO_RADIANS", "Math", "PI", "getDeckInstance", "map", "gl", "deck", "__deck", "customRender", "props", "_customRender", "onLoad", "deckProps", "getInterleavedProps", "triggerRepaint", "deckInstance", "Object", "assign", "width", "height", "touchAction", "viewState", "getViewState", "isInitialized", "watchMapMove", "setProps", "userData", "isExternal", "Deck", "on", "removeDeckInstance", "mapboxLayers", "Set", "afterRender", "_handleMapMove", "onMapMove", "off", "finalize", "currProps", "nextProps", "parameters", "depthMask", "depthTest", "blend", "blendFunc", "polygonOffsetFill", "depthFunc", "blendEquation", "views", "MapView", "id", "addLayer", "layer", "add", "updateLayers", "removeLayer", "delete", "updateLayer", "drawLayer", "currentViewport", "clearStack", "getViewport", "_drawLayers", "viewports", "layerFilter", "deckLayer", "operation", "includes", "clearCanvas", "lng", "lat", "getCenter", "longitude", "latitude", "zoom", "getZoom", "bearing", "getBearing", "pitch", "getPitch", "padding", "getPadding", "repeat", "getRenderWorldCopies", "getTerrain", "centerCameraOnTerrain", "getFreeCameraOptions", "position", "z", "undefined", "transform", "cameraX", "x", "cameraY", "y", "cameraZ", "center", "lngLatToWorld", "dx", "dy", "cameraToCenterDistanceGround", "sqrt", "pitchRadians", "altitudePixels", "scale", "cos", "sin", "log2", "cameraZFromSurface", "surfaceElevation", "unitsPerMeter", "elevation", "useMapboxProjection", "WebMercatorViewport", "nearZMultiplier", "nearZ", "_nearZ", "farZ", "_farZ", "mapboxLayerIds", "Array", "from", "deckLayers", "flatten", "layers", "Boolean", "hasNonMapboxLayers", "some", "getViewports", "mapboxViewportIdx", "findIndex", "vp", "hasNonMapboxViews", "length", "slice", "params", "viewport", "needsRedraw", "clearRedrawFlags", "forEach", "LayerType", "type", "push", "MapboxLayer", "constructor", "props", "id", "Error", "type", "renderingMode", "map", "deck", "onAdd", "gl", "getDeckInstance", "addLayer", "onRemove", "removeLayer", "setProps", "Object", "assign", "updateLayer", "render", "drawLayer", "UNDEFINED_BEFORE_ID", "resolveLayers", "map", "deck", "oldLayers", "newLayers", "style", "_loaded", "layers", "flatten", "Boolean", "prevLayers", "prevLayerIds", "Set", "l", "id", "layer", "delete", "getLayer", "removeLayer", "mapboxLayer", "implementation", "setProps", "props", "addLayer", "MapboxLayer", "beforeId", "mapLayers", "_order", "layerGroups", "includes", "push", "layerGroup", "lastLayerIndex", "length", "indexOf", "lastLayerId", "undefined", "i", "layerId", "layerIndex", "moveLayer", "MapboxOverlay", "constructor", "props", "resolveLayers", "_map", "_deck", "_props", "layers", "_container", "clientWidth", "clientHeight", "getContainer", "Object", "assign", "style", "width", "height", "deck", "setProps", "viewState", "getViewState", "isInitialized", "redraw", "event", "mockEvent", "type", "offsetCenter", "point", "srcEvent", "lastDown", "_lastMouseDownPoint", "deltaX", "originalEvent", "clientX", "deltaY", "clientY", "x", "y", "_onPointerDown", "_onEvent", "tapCount", "_onPointerMove", "interleaved", "otherProps", "_interleaved", "getInterleavedProps", "onAdd", "map", "_onAddInterleaved", "_onAddOverlaid", "container", "document", "createElement", "position", "left", "top", "textAlign", "pointerEvents", "Deck", "parent", "on", "_updateContainerSize", "_updateViewState", "_handleMouseEvent", "getDeckInstance", "gl", "painter", "context", "_handleStyleChange", "onRemove", "_onRemoveInterleaved", "_onRemoveOverlaid", "undefined", "off", "finalize", "removeDeckInstance", "getDefaultPosition", "pickObject", "params", "assert", "pickMultipleObjects", "pickObjects", "removeControl", "getCanvas"]
}
